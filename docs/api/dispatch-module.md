# TMS DispatchModule Implementation

## Overview
Complete driver management and automated dispatch system with SMS communication, two-way messaging, and multi-tenant security.

## Features Implemented

### üë®‚Äç‚úàÔ∏è **Data Layer (Entities)**
- **DriverEntity**: Complete driver profiles with CDL, endorsements, performance metrics
- **DispatchAssignmentEntity**: Full dispatch lifecycle with audit trails
- **Multi-tenancy**: All entities include `tenant_id` for data isolation

### üì± **Communication Abstraction (Adapter Pattern)**
- **ISmsProvider Interface**: Swappable SMS provider interface
- **MockSmsProvider**: Development provider with console logging
- **SignalWireService**: Production-ready implementation example
- **Provider Swapping**: Easy switching via dependency injection

### üìã **Dispatch Service (Automated)**
- **The "Magic" Message**: "Dispatch Alert: Load [Ref#] picking up in [City, State] at [Time]. Reply '1' to Confirm, '2' to Reject."
- **State Machine**: DISPATCHED ‚Üí CONFIRMED/REJECTED/COMPLETED
- **Transaction Safety**: Database transactions for state transitions
- **Driver Validation**: CDL expiration, medical certificates, availability

### üîó **Webhook Handler (Two-Way SMS)**
- **Inbound SMS Processing**: Parse driver responses (1=confirm, 2=reject)
- **Provider Detection**: Automatically detect Twilio, SignalWire, etc.
- **Response Processing**: Update dispatch assignments automatically
- **Security**: Signature validation and rate limiting

## API Endpoints

### Driver Management
```typescript
POST   /dispatch/drivers             // Create driver (Admin/Dispatcher)
GET    /dispatch/drivers             // List drivers with filters
GET    /dispatch/drivers/:id         // Get driver by ID
GET    /dispatch/drivers/:id/availability // Get driver availability
POST   /dispatch/drivers/:id/status  // Update driver status
POST   /dispatch/drivers/:id/location // Update driver location
```

### Dispatch Operations
```typescript
POST   /dispatch/assign             // Assign driver to shipment
GET    /dispatch/assignments        // Get dispatch assignments
GET    /dispatch/assignments/:id    // Get assignment by ID
GET    /dispatch/stats              // Get dispatch statistics
```

### Webhooks (Two-Way Communication)
```typescript
POST   /webhooks/sms/inbound      // Receive driver SMS responses
POST   /webhooks/sms/delivery    // SMS delivery receipts
POST   /webhooks/health           // Webhook health check
POST   /webhooks/test             // Test webhook processing
```

## Communication Abstraction

### ISmsProvider Interface
```typescript
export interface ISmsProvider {
  sendSms(to: string, message: string): Promise<SmsResult>;
  healthCheck(): Promise<boolean>;
  getProviderInfo(): ProviderInfo;
}
```

### Provider Swapping
```typescript
// In module providers
{
  provide: 'SMS_PROVIDER',
  useClass: process.env.NODE_ENV === 'production' 
    ? SignalWireService 
    : MockSmsProvider,
}
```

### Mock vs Production
```typescript
// Development - MockSmsProvider
üì± [MOCK SMS] To: +15551234567
   Message: Dispatch Alert: Load L-2026-001 picking up in Chicago, IL at 08:00 AM. Reply '1' to Confirm, '2' to Reject.
   Length: 142 characters
   Status: SUCCESS

// Production - SignalWireService
üì± [SIGNALWIRE] Sending SMS to +15551234567
   Message: Same dispatch message
   Status: Delivered via real SMS API
```

## The "Magic" Dispatch Message

### Automated Message Construction
```typescript
private buildDispatchMessage(shipment: ShipmentEntity, driver: DriverEntity): string {
  const pickupTime = shipment.pickupWindowStart 
    ? new Date(shipment.pickupWindowStart).toLocaleString('en-US', { 
        weekday: 'short', 
        month: 'short', 
        day: 'numeric', 
        hour: 'numeric', 
        minute: '2-digit' 
      })
    : 'ASAP';

  const pickupLocation = `${shipment.shipperLocation.city}, ${shipment.shipperLocation.state}`;
  const destinationLocation = `${shipment.consigneeLocation.city}, ${shipment.consigneeLocation.state}`;
  const weight = shipment.totalWeight ? `${shipment.totalWeight.toLocaleString()} lbs` : 'Weight TBD';

  return `Dispatch Alert: Load ${shipment.referenceNumber} picking up in ${pickupLocation} at ${pickupTime}. Dest: ${destinationLocation}. ${weight}. Reply '1' to Confirm, '2' to Reject.`;
}
```

### Response Processing
```typescript
// Driver texts: "1"
‚Üí Status: CONFIRMED
‚Üí Shipment: BOOKED
‚Üí Assignment: CONFIRMED

// Driver texts: "2"
‚Üí Status: REJECTED  
‚Üí Shipment: TENDERED (for re-dispatch)
‚Üí Assignment: REJECTED
```

## State Machine Logic

### Dispatch Workflow
```typescript
// 1. Initial Dispatch
DISPATCHED ‚Üí {
  sentAt: new Date(),
  status: 'DISPATCHED',
  dispatchMessage: autoGenerated,
  smsSent: true
}

// 2. Driver Confirmation
DISPATCHED ‚Üí CONFIRMED ‚Üí {
  confirmedAt: new Date(),
  status: 'CONFIRMED', 
  shipmentStatus: 'BOOKED'
}

// 3. Driver Rejection
DISPATCHED ‚Üí REJECTED ‚Üí {
  rejectedAt: new Date(),
  status: 'REJECTED',
  shipmentStatus: 'TENDERED' // Available for re-dispatch
}
```

### Transaction Safety
```typescript
// All state changes in database transactions
await queryRunner.startTransaction();
try {
  // Update assignment
  await queryRunner.manager.update(DispatchAssignmentEntity, assignmentId, {
    status: newStatus,
    confirmedAt: confirmed ? new Date() : null,
  });

  // Update shipment
  await queryRunner.manager.update(ShipmentEntity, shipmentId, {
    status: shipmentStatus,
    assignedDriverId: confirmed ? driverId : null,
  });

  // Update driver
  await queryRunner.manager.update(DriverEntity, driverId, {
    status: driverStatus,
    lastDispatchDate: new Date(),
  });

  await queryRunner.commitTransaction();
} catch (error) {
  await queryRunner.rollbackTransaction();
}
```

## Webhook Processing

### SMS Response Parsing
```typescript
private parseSmsResponse(payload: SmsWebhookPayload): {
  response?: '1' | '2';
  driverId?: string;
  assignmentId?: string;
} {
  const body = payload.Body.trim().toLowerCase();
  
  // Direct responses
  if (body === '1' || body.toLowerCase().includes('confirm')) {
    return { response: '1' };
  } else if (body === '2' || body.toLowerCase().includes('reject')) {
    return { response: '2' };
  }

  // Enhanced pattern matching
  const confirmPatterns = [/confirm/i, /accept/i, /yes/i, /ok/i, /^1$/];
  const rejectPatterns = [/reject/i, /decline/i, /no/i, /^2$/];

  if (confirmPatterns.some(pattern => pattern.test(body))) {
    return { response: '1' };
  } else if (rejectPatterns.some(pattern => pattern.test(body))) {
    return { response: '2' };
  }

  return {}; // Unrecognized response
}
```

### Provider Detection
```typescript
private detectProvider(headers: Record<string, string>): string {
  const providerHeaders = {
    'twilio-sms-request-id': 'Twilio',
    'x-signalwire-context': 'SignalWire',
    'message Sid': 'SignalWire',
  };

  for (const [header, provider] of Object.entries(providerHeaders)) {
    if (headers[header]) {
      return provider;
    }
  }
  
  return 'Unknown';
}
```

## Usage Examples

### Assign Driver with SMS
```typescript
POST /dispatch/assign
Authorization: Bearer <token>
Content-Type: application/json

{
  "shipmentId": "uuid-shipment-123",
  "driverId": "uuid-driver-456",
  "message": "Special pickup instructions",
  "scheduledFor": "2024-01-17T08:00:00Z"
}

Response:
{
  "success": true,
  "message": "Dispatch sent to John Smith",
  "data": {
    "assignment": {
      "id": "uuid-assignment-789",
      "status": "DISPATCHED",
      "sentAt": "2024-01-16T15:30:00Z"
    },
    "smsResult": {
      "success": true,
      "messageId": "mock_1642345678901_abc123",
      "timestamp": "2024-01-16T15:30:01Z"
    },
    "nextActions": [
      "Driver will receive SMS with load details",
      "Driver can reply '1' to confirm or '2' to reject",
      "Monitor webhook for driver response",
      "SMS expires in 24 hours"
    ]
  }
}
```

### Driver SMS Response Webhook
```typescript
POST /webhooks/sms/inbound
Content-Type: application/json

{
  "From": "+15551234567",
  "To": "+15559876543", 
  "Body": "1",
  "MessageSid": "SM1642345678901"
}

Response:
{
  "success": true,
  "message": "Driver confirmed dispatch",
  "processedAt": "2024-01-16T16:15:23Z",
  "driverId": "uuid-driver-456",
  "assignmentId": "uuid-assignment-789",
  "nextAction": "Generate BOL and pickup documents"
}
```

## Security & Multi-Tenancy

### Tenant Isolation
```typescript
// All driver operations scoped to tenant
.where('driver.tenantId = :tenantId', { tenantId: user.companyId })

// Assignment queries include tenant validation
.andWhere('assignment.shipmentId = :shipmentId', { shipmentId })
.andWhere('assignment.driverId = :driverId', { driverId })
```

### RBAC Authorization
```typescript
@Post('assign')
@Roles('admin', 'dispatcher')          // Only Admin/Dispatcher can dispatch
@Permissions('dispatch:create')        // Requires dispatch permission
async assignDriver() {
  // State machine logic with SMS automation
}
```

This implementation provides enterprise-grade dispatch management with automated two-way SMS communication, provider abstraction, and complete multi-tenant security for TMS operations.